<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Kubernetes Security Basics: From a Pentester’s Point of View | From Bits to Bytes | Cybersecurity Insights by Bhavik Kanejiya</title>
<meta name="keywords" content="Kubernetes Security, Cloud Security, Kubernetes">
<meta name="description" content="Explore Kubernetes security from a pentester&rsquo;s point of view. Follow a hands-on walkthrough from reconnaissance to root access, focusing on network packet analysis, exploitation techniques, and cluster misconfigurations">
<meta name="author" content="Bhavik Kanejiya">
<link rel="canonical" href="https://bhavik-kanejiya.github.io/blog/kubernetes-security-basics-from-a-pentesters-point-of-view/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://bhavik-kanejiya.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://bhavik-kanejiya.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://bhavik-kanejiya.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://bhavik-kanejiya.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://bhavik-kanejiya.github.io/android-chrome-192x192.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://bhavik-kanejiya.github.io/blog/kubernetes-security-basics-from-a-pentesters-point-of-view/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://bhavik-kanejiya.github.io/blog/kubernetes-security-basics-from-a-pentesters-point-of-view/">
  <meta property="og:site_name" content="From Bits to Bytes | Cybersecurity Insights by Bhavik Kanejiya">
  <meta property="og:title" content="Kubernetes Security Basics: From a Pentester’s Point of View">
  <meta property="og:description" content="Explore Kubernetes security from a pentester’s point of view. Follow a hands-on walkthrough from reconnaissance to root access, focusing on network packet analysis, exploitation techniques, and cluster misconfigurations">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2025-05-29T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-05-29T00:00:00+00:00">
    <meta property="article:tag" content="Kubernetes Security">
    <meta property="article:tag" content="Cloud Security">
    <meta property="article:tag" content="Kubernetes">
    <meta property="og:image" content="https://bhavik-kanejiya.github.io/images/K8-P1/1._K8_-_P1_-_Banner.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://bhavik-kanejiya.github.io/images/K8-P1/1._K8_-_P1_-_Banner.png">
<meta name="twitter:title" content="Kubernetes Security Basics: From a Pentester’s Point of View">
<meta name="twitter:description" content="Explore Kubernetes security from a pentester&rsquo;s point of view. Follow a hands-on walkthrough from reconnaissance to root access, focusing on network packet analysis, exploitation techniques, and cluster misconfigurations">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "https://bhavik-kanejiya.github.io/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Kubernetes Security Basics: From a Pentester’s Point of View",
      "item": "https://bhavik-kanejiya.github.io/blog/kubernetes-security-basics-from-a-pentesters-point-of-view/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kubernetes Security Basics: From a Pentester’s Point of View",
  "name": "Kubernetes Security Basics: From a Pentester’s Point of View",
  "description": "Explore Kubernetes security from a pentester\u0026rsquo;s point of view. Follow a hands-on walkthrough from reconnaissance to root access, focusing on network packet analysis, exploitation techniques, and cluster misconfigurations",
  "keywords": [
    "Kubernetes Security", "Cloud Security", "Kubernetes"
  ],
  "articleBody": "\nIntroduction For anyone in cybersecurity, two questions inevitably arise: What is Kubernetes, and what are the common security risks associated with it? These topics often seem complicated or are explained in overly technical terms.\nThis series provides a practical, hands-on journey through Kubernetes security. I will break down complex concepts into simple explanations, covering:\nKubernetes fundamentals Setting up K8s pentesting labs Common security issues and exploitation techniques Remediation and defense strategies I hope this series will transform your understanding of Kubernetes security. Let’s dive in.\nWhat and Why of Kubernetes? The name Kubernetes originates from Greek, meaning helmsman or pilot. The abbreviation K8s comes from counting the eight letters between “K” and “s”. Google open-sourced the Kubernetes project in 2014.\nCompanies use Kubernetes for several key reasons:\nAutomated deployment and scaling - Deploy applications and scale them automatically based on demand Self-healing - Restarts failed containers, replaces unhealthy ones, and reschedules workloads when nodes fail Load balancing and service discovery - Distributes traffic efficiently and allows services to find and communicate with each other Storage orchestration - Manages persistent and ephemeral storage for applications RBAC and security controls - Implements access control, network policies, and secrets management for secure workloads One of the best examples we can see nowadays is JioHotstar. They have shared multiple blogs on Kubernetes, including how they shifted their entire infrastructure from Amazon EC2 to Kubernetes and how they scaled up during special events like IPL or the Cricket World Cup. If you’re interested in real-world Kubernetes engineering insights, I highly recommend checking out their blog at blog.hotstar.com.\nIt’s important to understand that such large-scale implementations help us see the real security challenges that come with Kubernetes. As we dive deeper into Kubernetes pentesting, we’ll explore potential misconfigurations, security risks, and how to protect such critical infrastructure.\nKubernetes Architecture Let’s understand the Kubernetes architecture using this simple diagram.\nA Kubernetes deployment is called a cluster. A cluster consists of at least one Control Plane (also called Master Node) and one or more Worker Nodes. These can be physical devices, virtual machines, or instances in the cloud.\nControl Plane The Control Plane is the central management layer that maintains the desired state of the cluster. It’s essentially the “brain” of the Kubernetes cluster, making decisions about scheduling, detecting events, and ensuring the cluster operates as intended.\nKey components include the API server, etcd, controller manager, scheduler, and cloud controller manager. It receives information about cluster activity and requests, then uses this information to adjust cluster resources to the desired state. It decides which nodes should run which pods, ensuring optimal resource utilization. In production environments, the control plane usually runs across multiple machines for fault tolerance and high availability. The Control Plane runs on dedicated master nodes, separate from worker nodes that run the actual application workloads. This separation ensures high availability and reliability of the management components.\nWorker Node A worker node, or simply a node, is a physical or virtual machine that runs containerized applications (Pods) in a Kubernetes cluster. While the Control Plane manages the cluster, worker nodes execute workloads by hosting and running Pods.\nEach node can run multiple Pods, depending on its available resources. Worker nodes communicate with the Control Plane to receive instructions and report status. As the core of the Kubernetes data plane, worker nodes handle application execution and networking, ensuring seamless communication between services within and outside the cluster. If the Control Plane is the brain of Kubernetes, then worker nodes are its muscles, executing tasks and running applications. Control Plane Components Kube Control Manager In Kubernetes, a controller is a control loop that watches the shared state of the cluster through the API server and makes changes to move the current state toward the desired state.\nThe kube-controller-manager component is a collection of multiple controllers included in a single binary. This design reduces complexity by running all controllers in a single process. It’s responsible for running multiple controllers that maintain the desired state of the cluster.\nExamples of controllers include the replication controller, endpoints controller, namespace controller, and service accounts controller.\nThe kube-controller-manager constantly monitors the cluster’s state through the Kubernetes API server, tracking the configuration of Pods, Deployments, Services, and other resources. It compares the desired state (as defined in Kubernetes manifests) with the actual state to identify discrepancies. When deviations are detected, the appropriate controllers take action to rectify the situation, such as scaling Pods, restarting failed containers, or recreating resources as needed. Etcd etcd is a fast and highly available distributed key-value database that Kubernetes uses to store all cluster data. Each resource in a cluster has a key in the database. Essentially, etcd stores all cluster data from which the API server can collect and decide how to bridge the current and desired state. Scheduler In Kubernetes, scheduling ensures that Pods are matched to Nodes so that the Kubelet can run them. A scheduler watches for newly created Pods that have no Node assigned. For every Pod that the scheduler discovers, it becomes responsible for finding the best Node for that Pod to run on. The kube-scheduler is a control plane component that determines which node a Pod will run on, ensuring pods are assigned to suitable nodes based on resource availability and constraints. Cloud Controller Manager The cloud-controller-manager is a Kubernetes control plane component that manages cloud-specific operations. It connects your cluster to your cloud provider’s API and separates cloud platform interactions from cluster-only operations. This decoupling of cloud infrastructure logic allows cloud providers to develop and release their features independently from the main Kubernetes project. The cloud-controller-manager uses a plugin architecture, enabling various cloud providers to integrate their platforms with Kubernetes. Worker Node Components Kubelet The kubelet is the main Kubernetes agent that runs on every worker node and is responsible for running the actual containers. Its primary job is to watch the API server for new work tasks. When it detects a task, it executes it and maintains a reporting channel back to the control plane. If the kubelet cannot execute a task, it reports back to the control plane, which then decides what action to take. Kube-proxy Kube-proxy runs on every node and handles local cluster networking by routing network communication between pods and the network. It assigns each node a unique IP address and implements local tables or IPVS rules to manage the routing and load balancing of Pod network traffic. Container Runtime Each node requires a container runtime. The kubelet relies on this runtime to perform container-related tasks such as pulling images, starting containers, and stopping containers. Security Landscape Overview As organizations rapidly migrate to Kubernetes, security teams find themselves in a paradox: the very features that make containers powerful like isolation, orchestration, and their ephemeral nature also create unique security blind spots that traditional tools can’t address.\nConverting monolithic application deployments into microservices using Kubernetes streamlines the entire process. But does this mean it’s a more secure architecture? No. Kubernetes has multiple components that can be easily misconfigured and become targets for attackers. These misconfigurations are commonly overlooked when deploying applications. Ignoring such basic configuration settings can lead to serious security vulnerabilities.\nThe Kubernetes Security Report 2025 by Wiz reveals several concerning findings:\n21% of publicly exposed pods are running with at least one critical or high vulnerability. Over 9% of pods have sensitive host mapping, and 10% of pods are running as root. More than 60% of clusters exposed sensitive information like secrets and config maps. Many clusters lack proper network segmentation or access controls. These statistics highlight that securing Kubernetes requires a deeper understanding of its architecture, configurations, and runtime behavior not just default deployments or surface-level hardening.\nThe gap between Kubernetes adoption and security maturity creates a critical window of vulnerability for many organizations. In most cases, security is implemented after operational deployment and that delay is part of the problem.\nTo accelerate and strengthen security implementation, we’ve seen significant research and tooling development around Kubernetes. The Cloud Native Computing Foundation (CNCF) has developed comprehensive security frameworks, and numerous specialized tools have emerged for Kubernetes security assessment and hardening. Notable tools include Kube-bench, Calico, KubeLinter, Kube-hunter, Kubeaudit, Kubescape, Cilium, Falco, Checkov, and many more.\nIntroduction Kubernetes Threat Modeling Before diving into attacks, it’s important to understand the complexity of Kubernetes. It consists of multiple interconnected components. The API Server acts as the central control point, the Control Plane manages cluster operations, Pods host your applications, and etcd stores all cluster state and configuration data. This architectural complexity creates both power and risk. This is precisely why threat modeling becomes essential for Kubernetes environments.\nMicrosoft has developed a comprehensive threat matrix specifically for Kubernetes that catalogs the most common attack techniques and tactics. This matrix serves as both a checklist and a roadmap, helping security teams understand not just what attacks are possible, but how they typically unfold in real-world scenarios.\nYou can use tools like Mermaid or diagrams.net to visualize your own Kubernetes threat models.\nMicrosoft Threat Matrix for Kubernetes One of the most widely recognized frameworks for understanding Kubernetes threats is the Microsoft Threat Matrix. It maps out common attacker goals and techniques specific to Kubernetes environments. Some notable examples include exposed sensitive interfaces, sidecar injection, and privilege escalation through service account tokens.\nThis matrix provides a structured way to visualize how attackers can navigate through various components of a cluster-making it an essential reference for anyone building a Kubernetes threat model.\nThese techniques serve as a starting point for building a tailored threat model based on your specific cluster configuration and risk surface.\nAttack Paths in Kubernetes Key Kubernetes components from a threat modeling lens:\nAPI Server: Validates and configures data for API objects including pods, services, replication controllers, and others etcd: Fast and highly available distributed key-value database Kubelet: Main Kubernetes agent that runs on every worker node and is responsible for running the actual containers Control Plane: Manages clusters and resources such as worker nodes and pods Node: Physical or virtual machine in the cluster that runs your application containers How attackers exploit these components and impact of it:\nAPI Server: Unauthorized access or privilege escalation via insecure RBAC or misconfigured API endpoints can lead to full cluster compromise etcd: Access to unencrypted etcd data store exposes secrets, configurations, and credentials, enabling full control over the cluster Kubelet: Exploitation of insecure Kubelet API or read-only port allows attackers to execute commands on pods or extract sensitive data Control Plane: Compromise of control plane components allows attackers to manipulate workloads, scheduling, and cluster-wide behavior Node: Container escape or compromised node via vulnerable runtime leads to host-level compromise and lateral movement within the cluster Conclusion: Why Kubernetes Threat Modeling is Crucial Kubernetes is not just an container orchestration platform. It’s complex distributed system where it helps to make entire deployment process easy and flexible but it also comes with misconfigurations, trust boundaries and expanded attack surface.\nThat’s where Threat modeling comes into the picture.\nThreat modeling helps you in:\nUnderstand how an attacker thinks by identifying the components and trust boundaries Prioritize the defense based on the real world risk not just compliance related checks Uncover the possibly weakest path ealy before they’re exploited in production TL;DR Threat modeling in kubernetes is not an optional - It’s early warning system\nTransform chaos into clarity Turn assumption into verified controls Helps to prevent security breach before it starts. In a Kubernetes environment, where shared responsibility, and rapid deployments are the norm, threat modeling provides a structured way to think offensively while acting defensively.\nReferences https://medium.com/devops-mojo/kubernetes-architecture-overview-introduction-to-k8s-architecture-and-understanding-k8s-cluster-components-90e11eb34ccd https://www.wiz.io/reports/kubernetes-security-report-2025 https://blog.hotstar.com/ https://www.wiz.io/blog/making-sense-of-kubernetes-initial-access-vectors-part-1-control-plane https://notes.kodekloud.com/ https://www.wiz.io/academy/top-kubernetes-security-tools https://microsoft.github.io/Threat-Matrix-for-Kubernetes https://offensivebytes.com/offensive-container-security Coming next In the next blog post, we will shift from theory to action, exploring initial access and reconnaissance techniques in Kubernetes.\nWe will also examine how exposed clusters are attacked and what you can do to stop them.\nStay tuned. The attack surface is waiting.\n",
  "wordCount" : "1985",
  "inLanguage": "en",
  "image":"https://bhavik-kanejiya.github.io/images/K8-P1/1._K8_-_P1_-_Banner.png","datePublished": "2025-05-29T00:00:00Z",
  "dateModified": "2025-05-29T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "Bhavik Kanejiya"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://bhavik-kanejiya.github.io/blog/kubernetes-security-basics-from-a-pentesters-point-of-view/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "From Bits to Bytes | Cybersecurity Insights by Bhavik Kanejiya",
    "logo": {
      "@type": "ImageObject",
      "url": "https://bhavik-kanejiya.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://bhavik-kanejiya.github.io/" accesskey="h" title="Home (Alt + H)">
                <img src="https://bhavik-kanejiya.github.io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="35">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://bhavik-kanejiya.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://bhavik-kanejiya.github.io/blog/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://bhavik-kanejiya.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://bhavik-kanejiya.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Kubernetes Security Basics: From a Pentester’s Point of View
    </h1>
    <div class="post-meta"><span title='2025-05-29 00:00:00 +0000 UTC'>May 29, 2025</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Bhavik Kanejiya

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#what-and-why-of-kubernetes" aria-label="What and Why of Kubernetes?">What and Why of Kubernetes?</a></li>
                <li>
                    <a href="#kubernetes-architecture" aria-label="Kubernetes Architecture">Kubernetes Architecture</a><ul>
                        
                <li>
                    <a href="#control-plane" aria-label="Control Plane">Control Plane</a></li>
                <li>
                    <a href="#worker-node" aria-label="Worker Node">Worker Node</a></li></ul>
                </li>
                <li>
                    <a href="#control-plane-components" aria-label="Control Plane Components">Control Plane Components</a><ul>
                        
                <li>
                    <a href="#kube-control-manager" aria-label="Kube Control Manager">Kube Control Manager</a></li>
                <li>
                    <a href="#etcd" aria-label="Etcd">Etcd</a></li>
                <li>
                    <a href="#scheduler" aria-label="Scheduler">Scheduler</a></li>
                <li>
                    <a href="#cloud-controller-manager" aria-label="Cloud Controller Manager">Cloud Controller Manager</a></li></ul>
                </li>
                <li>
                    <a href="#worker-node-components" aria-label="Worker Node Components">Worker Node Components</a><ul>
                        
                <li>
                    <a href="#kubelet" aria-label="Kubelet">Kubelet</a></li>
                <li>
                    <a href="#kube-proxy" aria-label="Kube-proxy">Kube-proxy</a></li>
                <li>
                    <a href="#container-runtime" aria-label="Container Runtime">Container Runtime</a></li></ul>
                </li>
                <li>
                    <a href="#security-landscape-overview" aria-label="Security Landscape Overview">Security Landscape Overview</a></li>
                <li>
                    <a href="#introduction-kubernetes-threat-modeling" aria-label="Introduction Kubernetes Threat Modeling">Introduction Kubernetes Threat Modeling</a><ul>
                        
                <li>
                    <a href="#microsoft-threat-matrix-for-kubernetes" aria-label="Microsoft Threat Matrix for Kubernetes">Microsoft Threat Matrix for Kubernetes</a></li>
                <li>
                    <a href="#attack-paths-in-kubernetes" aria-label="Attack Paths in Kubernetes">Attack Paths in Kubernetes</a></li>
                <li>
                    <a href="#conclusion-why-kubernetes-threat-modeling-is-crucial" aria-label="Conclusion: Why Kubernetes Threat Modeling is Crucial">Conclusion: Why Kubernetes Threat Modeling is Crucial</a></li>
                <li>
                    <a href="#tldr" aria-label="TL;DR">TL;DR</a></li></ul>
                </li>
                <li>
                    <a href="#references" aria-label="References">References</a></li>
                <li>
                    <a href="#coming-next" aria-label="Coming next">Coming next</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p><img alt="K8 - Banner" loading="lazy" src="/images/K8-P1/1._K8_-_P1_-_Banner.png"></p>
<h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>For anyone in cybersecurity, two questions inevitably arise: <strong>What is Kubernetes,</strong> and <strong>what are the common security risks associated with it?</strong> These topics often seem complicated or are explained in overly technical terms.</p>
<p>This series provides a practical, hands-on journey through Kubernetes security. I will break down complex concepts into simple explanations, covering:</p>
<ul>
<li>Kubernetes fundamentals</li>
<li>Setting up K8s pentesting labs</li>
<li>Common security issues and exploitation techniques</li>
<li>Remediation and defense strategies</li>
</ul>
<p>I hope this series will transform your understanding of Kubernetes security. Let&rsquo;s dive in.</p>
<h2 id="what-and-why-of-kubernetes">What and Why of Kubernetes?<a hidden class="anchor" aria-hidden="true" href="#what-and-why-of-kubernetes">#</a></h2>
<p>The name Kubernetes <strong>originates from Greek</strong>, meaning <strong>helmsman</strong> or <strong>pilot</strong>. The abbreviation K8s comes from counting the eight letters between &ldquo;K&rdquo; and &ldquo;s&rdquo;. Google open-sourced the Kubernetes project in 2014.</p>
<p><strong>Companies use Kubernetes for several key reasons:</strong></p>
<ul>
<li><strong>Automated deployment and scaling</strong> - Deploy applications and scale them automatically based on demand</li>
<li><strong>Self-healing</strong> - Restarts failed containers, replaces unhealthy ones, and reschedules workloads when nodes fail</li>
<li><strong>Load balancing and service discovery</strong> - Distributes traffic efficiently and allows services to find and communicate with each other</li>
<li><strong>Storage orchestration</strong> - Manages persistent and ephemeral storage for applications</li>
<li><strong>RBAC and security controls</strong> - Implements access control, network policies, and secrets management for secure workloads</li>
</ul>
<p>One of the best examples we can see nowadays is <strong>JioHotstar</strong>. They have shared multiple blogs on Kubernetes, including how they shifted their entire infrastructure from <strong>Amazon EC2 to Kubernetes</strong> and how they scaled up during special events like <strong>IPL</strong> or the <strong>Cricket World Cup</strong>. If you&rsquo;re interested in <strong>real-world Kubernetes engineering insights</strong>, I highly recommend checking out their blog at <a href="https://blog.hotstar.com/"><strong>blog.hotstar.com</strong></a>.</p>
<p>It&rsquo;s important to understand that such large-scale implementations help us see the <strong>real security challenges</strong> that come with Kubernetes. As we dive deeper into Kubernetes pentesting, we&rsquo;ll explore <strong>potential misconfigurations, security risks, and how to protect such critical infrastructure</strong>.</p>
<h2 id="kubernetes-architecture">Kubernetes Architecture<a hidden class="anchor" aria-hidden="true" href="#kubernetes-architecture">#</a></h2>
<p>Let&rsquo;s understand the Kubernetes architecture using this simple diagram.</p>
<p><img alt="Kubernetes Architecture" loading="lazy" src="/images/K8-P1/2._K8_Architecture.png"></p>
<p>A Kubernetes deployment is called a cluster. A cluster consists of at least one Control Plane (also called Master Node) and one or more Worker Nodes. These can be physical devices, virtual machines, or instances in the cloud.</p>
<h3 id="control-plane">Control Plane<a hidden class="anchor" aria-hidden="true" href="#control-plane">#</a></h3>
<p>The Control Plane is the central management layer that maintains the desired state of the cluster. It’s essentially the “brain” of the Kubernetes cluster, making decisions about scheduling, detecting events, and ensuring the cluster operates as intended.</p>
<ul>
<li>Key components include the API server, etcd, controller manager, scheduler, and cloud controller manager.</li>
<li>It receives information about cluster activity and requests, then uses this information to adjust cluster resources to the desired state.</li>
<li>It decides which nodes should run which pods, ensuring optimal resource utilization.</li>
<li>In production environments, the control plane usually runs across multiple machines for fault tolerance and high availability.</li>
</ul>
<p>The Control Plane runs on dedicated master nodes, separate from worker nodes that run the actual application workloads. This separation ensures high availability and reliability of the management components.</p>
<h3 id="worker-node">Worker Node<a hidden class="anchor" aria-hidden="true" href="#worker-node">#</a></h3>
<p>A <strong>worker node</strong>, or simply a <strong>node</strong>, is a physical or virtual machine that runs containerized applications (Pods) in a Kubernetes cluster. While the <strong>Control Plane</strong> manages the cluster, worker nodes execute workloads by hosting and running Pods.</p>
<ul>
<li>Each node can run multiple Pods, depending on its available resources. Worker nodes communicate with the <strong>Control Plane</strong> to receive instructions and report status.</li>
<li>As the <strong>core of the Kubernetes data plane</strong>, worker nodes handle application execution and networking, ensuring seamless communication between services within and outside the cluster.</li>
<li>If the <strong>Control Plane</strong> is the brain of Kubernetes, then worker nodes are its muscles, executing tasks and running applications.</li>
</ul>
<h2 id="control-plane-components">Control Plane Components<a hidden class="anchor" aria-hidden="true" href="#control-plane-components">#</a></h2>
<h3 id="kube-control-manager">Kube Control Manager<a hidden class="anchor" aria-hidden="true" href="#kube-control-manager">#</a></h3>
<p>In Kubernetes, a <strong>controller</strong> is a control loop that watches the shared state of the cluster through the API server and makes changes to move the current state toward the desired state.</p>
<p>The kube-controller-manager component is a collection of multiple controllers included in a single binary. This design reduces complexity by running all controllers in a single process. It’s responsible for running multiple controllers that maintain the desired state of the cluster.</p>
<p>Examples of controllers include the replication controller, endpoints controller, namespace controller, and service accounts controller.</p>
<ul>
<li>The kube-controller-manager constantly monitors the cluster’s state through the Kubernetes API server, tracking the configuration of Pods, Deployments, Services, and other resources.</li>
<li>It compares the desired state (as defined in Kubernetes manifests) with the actual state to identify discrepancies.</li>
<li>When deviations are detected, the appropriate controllers take action to rectify the situation, such as scaling Pods, restarting failed containers, or recreating resources as needed.</li>
</ul>
<h3 id="etcd">Etcd<a hidden class="anchor" aria-hidden="true" href="#etcd">#</a></h3>
<ul>
<li>etcd is a fast and highly available distributed key-value database that Kubernetes uses to store all cluster data. Each resource in a cluster has a key in the database.</li>
<li>Essentially, etcd stores all cluster data from which the API server can collect and decide how to bridge the current and desired state.</li>
</ul>
<h3 id="scheduler">Scheduler<a hidden class="anchor" aria-hidden="true" href="#scheduler">#</a></h3>
<ul>
<li>In Kubernetes, scheduling ensures that <a href="https://kubernetes.io/docs/concepts/workloads/pods/">Pods</a> are matched to <a href="https://kubernetes.io/docs/concepts/architecture/nodes/">Nodes</a> so that the <a href="https://kubernetes.io/docs/reference/generated/kubelet">Kubelet</a> can run them.</li>
<li>A scheduler watches for newly created Pods that have no Node assigned. For every Pod that the scheduler discovers, it becomes responsible for finding the best Node for that Pod to run on.</li>
<li>The kube-scheduler is a control plane component that determines which node a Pod will run on, ensuring pods are assigned to suitable nodes based on resource availability and constraints.</li>
</ul>
<h3 id="cloud-controller-manager">Cloud Controller Manager<a hidden class="anchor" aria-hidden="true" href="#cloud-controller-manager">#</a></h3>
<ul>
<li>The cloud-controller-manager is a Kubernetes <a href="https://kubernetes.io/docs/reference/glossary/?all=true#term-control-plane">control plane</a> component that manages cloud-specific operations. It connects your cluster to your cloud provider’s API and separates cloud platform interactions from cluster-only operations.</li>
<li>This decoupling of cloud infrastructure logic allows cloud providers to develop and release their features independently from the main Kubernetes project.</li>
<li>The cloud-controller-manager uses a plugin architecture, enabling various cloud providers to integrate their platforms with Kubernetes.</li>
</ul>
<h2 id="worker-node-components">Worker Node Components<a hidden class="anchor" aria-hidden="true" href="#worker-node-components">#</a></h2>
<h3 id="kubelet">Kubelet<a hidden class="anchor" aria-hidden="true" href="#kubelet">#</a></h3>
<ul>
<li>The kubelet is the main Kubernetes agent that runs on every worker node and is responsible for running the actual containers.</li>
<li>Its primary job is to watch the API server for new work tasks. When it detects a task, it executes it and maintains a reporting channel back to the control plane.</li>
<li>If the kubelet cannot execute a task, it reports back to the control plane, which then decides what action to take.</li>
</ul>
<h3 id="kube-proxy">Kube-proxy<a hidden class="anchor" aria-hidden="true" href="#kube-proxy">#</a></h3>
<ul>
<li>Kube-proxy runs on every node and handles local cluster networking by routing network communication between pods and the network.</li>
<li>It assigns each node a unique IP address and implements local tables or IPVS rules to manage the routing and load balancing of Pod network traffic.</li>
</ul>
<h3 id="container-runtime">Container Runtime<a hidden class="anchor" aria-hidden="true" href="#container-runtime">#</a></h3>
<ul>
<li>Each node requires a container runtime. The kubelet relies on this runtime to perform container-related tasks such as pulling images, starting containers, and stopping containers.</li>
</ul>
<h2 id="security-landscape-overview">Security Landscape Overview<a hidden class="anchor" aria-hidden="true" href="#security-landscape-overview">#</a></h2>
<p>As organizations rapidly migrate to Kubernetes, security teams find themselves in a paradox: the very features that make containers powerful like isolation, orchestration, and their ephemeral nature also create unique security blind spots that traditional tools can’t address.</p>
<p>Converting monolithic application deployments into microservices using Kubernetes streamlines the entire process. But does this mean it’s a more secure architecture? No. Kubernetes has multiple components that can be easily misconfigured and become targets for attackers. These misconfigurations are commonly overlooked when deploying applications. Ignoring such basic configuration settings can lead to serious security vulnerabilities.</p>
<p>The <a href="https://www.wiz.io/reports/kubernetes-security-report-2025">Kubernetes Security Report 2025 by Wiz</a> reveals several concerning findings:</p>
<ul>
<li>21% of publicly exposed pods are running with at least one critical or high vulnerability.</li>
<li>Over 9% of pods have sensitive host mapping, and 10% of pods are running as root.</li>
<li>More than 60% of clusters exposed sensitive information like secrets and config maps.</li>
<li>Many clusters lack proper network segmentation or access controls.</li>
</ul>
<p>These statistics highlight that securing Kubernetes requires a deeper understanding of its architecture, configurations, and runtime behavior not just default deployments or surface-level hardening.</p>
<p>The gap between Kubernetes adoption and security maturity creates a critical window of vulnerability for many organizations. In most cases, <strong>security is implemented after operational deployment</strong> and that delay is part of the problem.</p>
<p>To accelerate and strengthen security implementation, we’ve seen significant research and tooling development around Kubernetes. The <strong>Cloud Native Computing Foundation (CNCF)</strong> has developed comprehensive security frameworks, and numerous specialized tools have emerged for Kubernetes security assessment and hardening. Notable tools include Kube-bench, Calico, KubeLinter, Kube-hunter, Kubeaudit, Kubescape, Cilium, Falco, Checkov, and many more.</p>
<h2 id="introduction-kubernetes-threat-modeling">Introduction Kubernetes Threat Modeling<a hidden class="anchor" aria-hidden="true" href="#introduction-kubernetes-threat-modeling">#</a></h2>
<p>Before diving into attacks, it’s important to understand the complexity of Kubernetes. It consists of multiple interconnected components. The API Server acts as the central control point, the Control Plane manages cluster operations, Pods host your applications, and etcd stores all cluster state and configuration data. This architectural complexity creates both power and risk. This is precisely why threat modeling becomes essential for Kubernetes environments.</p>
<p>Microsoft has developed a comprehensive threat matrix specifically for Kubernetes that catalogs the most common attack techniques and tactics. This matrix serves as both a checklist and a roadmap, helping security teams understand not just what attacks are possible, but how they typically unfold in real-world scenarios.</p>
<blockquote>
<p>You can use tools like <a href="https://mermaidchart.com/">Mermaid</a> or <a href="https://app.diagrams.net/">diagrams.net</a> to visualize your own Kubernetes threat models.</p></blockquote>
<h3 id="microsoft-threat-matrix-for-kubernetes">Microsoft Threat Matrix for Kubernetes<a hidden class="anchor" aria-hidden="true" href="#microsoft-threat-matrix-for-kubernetes">#</a></h3>
<p><img alt="Microsoft Threat Matrix" loading="lazy" src="/images/K8-P1/3._Threat_Model_image.png"></p>
<p>One of the most widely recognized frameworks for understanding Kubernetes threats is the Microsoft Threat Matrix. It maps out common attacker goals and techniques specific to Kubernetes environments. Some notable examples include exposed sensitive interfaces, sidecar injection, and privilege escalation through service account tokens.</p>
<p>This matrix provides a structured way to visualize how attackers can navigate through various components of a cluster-making it an essential reference for anyone building a Kubernetes threat model.</p>
<blockquote>
<p>These techniques serve as a starting point for building a tailored threat model based on your specific cluster configuration and risk surface.</p></blockquote>
<h3 id="attack-paths-in-kubernetes">Attack Paths in Kubernetes<a hidden class="anchor" aria-hidden="true" href="#attack-paths-in-kubernetes">#</a></h3>
<p><img alt="Threat Model" loading="lazy" src="/images/K8-P1/4._Threat_Model_-_Solid.png"></p>
<p><strong>Key Kubernetes components from a threat modeling lens:</strong></p>
<ul>
<li><strong>API Server:</strong> Validates and configures data for API objects including pods, services, replication controllers, and others</li>
<li><strong>etcd:</strong> Fast and highly available distributed key-value database</li>
<li><strong>Kubelet:</strong> Main Kubernetes agent that runs on every worker node and is responsible for running the actual containers</li>
<li><strong>Control Plane:</strong> Manages clusters and resources such as worker nodes and pods</li>
<li><strong>Node:</strong> Physical or virtual machine in the cluster that runs your application containers</li>
</ul>
<p><strong>How attackers exploit these components and impact of it:</strong></p>
<ul>
<li><strong>API Server:</strong> Unauthorized access or privilege escalation via insecure RBAC or misconfigured API endpoints can lead to full cluster compromise</li>
<li><strong>etcd:</strong> Access to unencrypted etcd data store exposes secrets, configurations, and credentials, enabling full control over the cluster</li>
<li><strong>Kubelet:</strong> Exploitation of insecure Kubelet API or read-only port allows attackers to execute commands on pods or extract sensitive data</li>
<li><strong>Control Plane:</strong> Compromise of control plane components allows attackers to manipulate workloads, scheduling, and cluster-wide behavior</li>
<li><strong>Node:</strong> Container escape or compromised node via vulnerable runtime leads to host-level compromise and lateral movement within the cluster</li>
</ul>
<h3 id="conclusion-why-kubernetes-threat-modeling-is-crucial">Conclusion: Why Kubernetes Threat Modeling is Crucial<a hidden class="anchor" aria-hidden="true" href="#conclusion-why-kubernetes-threat-modeling-is-crucial">#</a></h3>
<p>Kubernetes is not just an container orchestration platform. It’s complex distributed system where it helps to make entire deployment process easy and flexible but it also comes with misconfigurations, trust boundaries and expanded attack surface.</p>
<p>That’s where Threat modeling comes into the picture.</p>
<p><strong>Threat modeling helps you in:</strong></p>
<ul>
<li>Understand how an attacker thinks by identifying the components and trust boundaries</li>
<li>Prioritize the defense based on the real world risk not just compliance related checks</li>
<li>Uncover the possibly weakest path ealy before they&rsquo;re exploited in production</li>
</ul>
<h3 id="tldr">TL;DR<a hidden class="anchor" aria-hidden="true" href="#tldr">#</a></h3>
<p>Threat modeling in kubernetes is not an optional - It’s early warning system</p>
<ul>
<li>Transform chaos into clarity</li>
<li>Turn assumption into verified controls</li>
<li>Helps to prevent security breach before it starts.</li>
</ul>
<p>In a Kubernetes environment, where shared responsibility, and rapid deployments are the norm, threat modeling provides a structured way to think offensively while acting defensively.</p>
<h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<ul>
<li><a href="https://medium.com/devops-mojo/kubernetes-architecture-overview-introduction-to-k8s-architecture-and-understanding-k8s-cluster-components-90e11eb34ccd">https://medium.com/devops-mojo/kubernetes-architecture-overview-introduction-to-k8s-architecture-and-understanding-k8s-cluster-components-90e11eb34ccd</a></li>
<li><a href="https://www.wiz.io/reports/kubernetes-security-report-2025">https://www.wiz.io/reports/kubernetes-security-report-2025</a></li>
<li><a href="https://blog.hotstar.com/">https://blog.hotstar.com/</a></li>
<li><a href="https://www.wiz.io/blog/making-sense-of-kubernetes-initial-access-vectors-part-1-control-plane">https://www.wiz.io/blog/making-sense-of-kubernetes-initial-access-vectors-part-1-control-plane</a></li>
<li><a href="https://notes.kodekloud.com/">https://notes.kodekloud.com/</a></li>
<li><a href="https://www.wiz.io/academy/top-kubernetes-security-tools">https://www.wiz.io/academy/top-kubernetes-security-tools</a></li>
<li><a href="https://microsoft.github.io/Threat-Matrix-for-Kubernetes/">https://microsoft.github.io/Threat-Matrix-for-Kubernetes</a></li>
<li><a href="https://offensivebytes.com/offensive-container-security">https://offensivebytes.com/offensive-container-security</a></li>
</ul>
<h2 id="coming-next">Coming next<a hidden class="anchor" aria-hidden="true" href="#coming-next">#</a></h2>
<p>In the next blog post, we will shift from theory to action, exploring initial access and reconnaissance techniques in Kubernetes.</p>
<p>We will also examine how exposed clusters are attacked and what you can do to stop them.</p>
<p>Stay tuned. The attack surface is waiting.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://bhavik-kanejiya.github.io/tags/kubernetes-security/">Kubernetes Security</a></li>
      <li><a href="https://bhavik-kanejiya.github.io/tags/cloud-security/">Cloud Security</a></li>
      <li><a href="https://bhavik-kanejiya.github.io/tags/kubernetes/">Kubernetes</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://bhavik-kanejiya.github.io/blog/htb-cap-walkthrough/">
    <span class="title">Next »</span>
    <br>
    <span>HTB Cap Walkthrough</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© 2025 Bhavik Kanejiya</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
